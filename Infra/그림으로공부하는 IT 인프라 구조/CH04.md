# **4. 인프라를 지탱하는 기본 이론**

## **4.1. 직렬/병렬**
### **4.1.1 직렬/병렬이란?**
- 최근 추세는 클럭 속도 향상보다 코어 수를 늘리는 방향으로 발전
- 무조건 병렬화 한다고 해서 성능이 향상되는 것은아니다. 병렬화환 하드웨어를 놀리지 않고 어떻게 효율적으로활용하는지가 중요
- 책에서는 직렬은 1차선, 병렬은 다차선 도로라고 설명하고 있다.
- 차선이 줄어드는 부분, 즉 **병목 현상**을 해결하는 방법이 중요하다.
- 또한 병렬화를 통해 진행한 일을 한곳에 모을때도 **오버헤드**가 발생한다.
> cpu와 gpu 연산 방법
> ![cpu-gpu](img/cpu_gpu.png)

- 직렬 처리 속도를 올리는 것에는 한계가 있다.
- 병렬화를 통해 속도가 올라간다기 보다는 단위 시간당 처리량이 올라간다.

### **4.1.2 어디에 사용 되나?**
**웹 서버와 AP 서버에서의 병렬화**
- 웹서버 에서는 다수의 이용자가 접속하기 때문에 복수의 프로세스가 분담해서 병렬 처리를 함
- Apache HTTP Server 에서는 멀티 프로세스(아파치 - prefork), 멀티 쓰레드 + 프로세스 를 섞어쓰는 모델 (아파치 - worker) 등이 있다.

> **여기서 우리는 멀티 프로세스 기반의 서버 / 멀티 쓰레드 기반의 서버 / 멀티 플렉싱 기반의 서버에 대한 이해가 필요하다.**
> - 멀티프로세스 기반 서버 : 다수의 프로세스를 생성하는 방식으로 서비스를 제공한다.
> - 멀티스레드 기반 서버 : 클라이언트의 수만큼 스레드를 생성하는 방식으로 서비스를 제공한다.
> - 멀티플렉싱 기반 서버 : 입출력 대상을 묶어서 관리하는 방식으로 서비스를 제공한다.
> https://jongmin92.github.io/2019/02/28/Java/java-with-non-blocking-io/
- 스레드를 무작정 늘리는 것은 옳지 않다. 특정 시점에 코어를 사용할 수 있는 것은 쓰레드 하나 밖에 없다.
- 일꾼이 아무리 많아도 일할 수 있는 도구가 없다면 소용없다.

**DB 서버에서의 병렬화**
- 오라클에서는 접속 수 만큼 프로세스가 생성된다.
- 또한 쓰기 작업시 병목이 발생하면 해당 작업을 하는 프로세스를 늘리는 방법이 있고, 비동기 I/O를 사용해서 OS측에 쓰기 처리를 병렬화 하는 방법도 있다.

### **4.1.3 정리**
- 병렬화 에서는 직렬 처리 성능이 향상되지는 않지만, 단위 시간당 처리량을 늘릴 수 있다.
- 합류점, 직렬화 구간, 분기점에서 병목이 발생한다.
- 최대 처리량의 기준은 처리 구간 중에서 가장 처리량이 낮은 구간이다.

> 동시성과 병렬성
> - 동시성은 싱글 코어에서 멀티 스레드를 동작시키는 방법
> - 병렬성은 멀티 코어에서 멀티 프로세스(스레드)를 동작 시키는 방법


## **4.2 동기/비동기**

### **4.2.1 동기/비동기란?**
- 누군가에게 일을 부탁하고 그 일이 끝나기까지 완료 여부를 기다리는 것이 동기 **(Blocking 아니야?)**
- 일을 부탁하고 '끝나면 말해(callback)' 라고 신경쓰지 않는것이 비동기
  
> https://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/
> - **Blocking/NonBlocking은 호출되는 함수가 바로 리턴하느냐 마느냐가 관심사**
>   - 바로 리턴하지 않으면 Blocking
>   - 바로 리턴하면 NonBlocking
> - **Synchronous/Asynchronous는 호출되는 함수의 작업 완료 여부를 누가 신경쓰냐가 관심사**
>   - 호출되는 함수의 작업 완료를 호출한 함수가 신경쓰면 Synchronous
>   - 호출되는 함수의 작업 완료를 호출된 함수가 신경쓰면 Asynchronous

### **4.2.2 어디에 사용되나?**
- Ajax 통신 (검색어 자동 완성을 예로 들고 있음)
- DBMS에서 쓰기 I/O 를 비동기로 실행 가능
  - 공유 메모리 내용을 HDD에 쓰는 과정에서 커널에 쓰기 의뢰 후 기다리지 않고 다음 쓰기 의뢰를 한다.

### **4.2.3 정리**
- 비동기로 요구한 처리가 끝나지 않은 상태에서 처리해도 다음 처리가 문제가 없을지 고려해야 한다.
- 비동기로 요구한 처리의 종료를 확인하는 방법에 대한 고려
  
> c10k 문제
> - 1만 클라이언트가 동시 접속하는 것을 버틸 수 있을까?
> - 이 문제 때문에 nginx가 처음 발표


## **4.3 큐**

### **4.3.1 큐란?**
- FIFO : First In, First Out / 先入先出
- 성능 튜닝, 메시지 큐, OS 등등 엄청나게 많은 곳에 쓰이고 있다.
- 대기 행렬은 끝부터 시작, 처리는 머리부터~!

### **4.3.2 어디에 사용되나?**
- CPU 처리를 기다리고 있는 프로세스나 스레드 행렬, 하드 디스크 등의 저장소 읽기 처리를 기다리고 있는 I/O 요구 행렬, 네트워크 접속 성립을 기다리고 있는 접속 요구 행렬 등등
- CPU 를 기다리고 있는 프로세스 행렬을 '런큐(Run-queue)' 라고 한다.
> mac os 에서는 vm_stat
> mac os 에서 커널 I/O의 통계를 보는 명령어 : iostat

**데이터베이스의 디스크 I/O**
- 데이터를 기록하는 DBWR, REDO LOG를 기록하는 LGWR 은 각각 다른 HDD에 쓰기를 요청해야 한다. 그렇기 때문에 각각 다른 QUEUE에 쓰기 요청을 한다.
- 프로세스나 스레드가 작업을 요청하는 대상이 CPU가 아닌 HDD 인 점만 다르다.

### **4.3.3 정리**
- 데이터베이스의 성능 문제와 관련해서는 데이터베이스 큐, OS 런큐, I/O 요청 큐 등을 확인하면 처리 지연이 발생하고 있는지 확인할 수 있다.
- 데이터 생산자와 소비자 입장에서도 큐(버퍼, 메시지 등등)를 활용한 작업이 많다.
  

## **4.4 배타적 제어**

### **4.4.1 배타적 제어란?**
- 공유하는 것에 대해서 사용중일 경우 다른 곳에서 접근 못하게 하는것이 배타적 제어
- 대부분 병렬 처리시에 필요하다.
- 또한 배타적 제어를 하는 부분에서 병목 현상이 발생하기 쉽다.
- OS, DBMS등 공유 데이터를 통해 병렬 작업을 하는 많은 곳에서 다양한 방식에 배타적 제어 컨셉을 사용하고 있다.
- 특징
  - 공유자원에 동시에 엑세스(대부분 갱신)하면 불일치로 인한 문제가 발생할 수 있다.
  - 지정된 처리만 공유 자원에 접근하게 해서 불일치가 발생하지 않도록 해야 한다.
  - 병목 현상이 발생할 수 있다.

### **4.4.2 어디에 사용되나?**
**DBMS에 사용되는 배타적 제어**
- DBMS에서 사용하는 배타적 제어 방법중 래치 또는 스핀락이라 불리는 아주 짧은 시간을 대기하는 방법이 있다.
  - 스핀락에 경우 빠르게 공유 자원에 접근 못할 경우 성능에 좋지않은 영향을 끼친다.
  - 컨텍스트 스위칭에 들어가는 리소스(시간)보다 대기에 필요한 리소스가 더 많이 들어갈 경우 리소스 낭비로 이어진다.
- 또한 계속해서 스핀락을 유지할지 아니면 슬립에 들어갈지 판단하는 adaptive lock 도 있다

> 뮤텍스, 세마포어 공부?!

**OS 커널에 사용되는 베타적 제어**
- 한번에 하나의 스레드만 커널 모드에서 동작하기 위해 사용되었다.
- 2011년 리눅스 커널 2.6.39 에서 최종적으로 삭제
  
### **4.4.3 정리**
- 배타적 제어를 사용하면 공유 데이터의 일관성은 지킬 수 있다.
- 다만 병렬처리가 어렵고 병목 현상이 발생할 수 있다.

> **멀티 프로세서에서는 배타적 제어가 어렵다**
> - 자바 에서는 Atomic 타입에서 사용하는 CAS(Compare And Swap) 방식을 사용한다.
> - 각각의 멀티 프로세서 캐시에서 가지고 있는 데이터 값을 참조하는것이 아니라 메모리에 있는 값을 참고한다.

## **4.5 상태 저장/상태 비저장**
### **4.5.1 상태 저장/상태 비저장이란?**
- 정보를 많이 가지고 있는 상태 저장은 세분화된 제어가 가능한 바면에 구조가 복잡 
- 상태 비저장은 간단하 구조
- 대표적 예로 ssh는 상태 저장 프로토콜, http는 상태 비저장 프로토콜이다.
- 상태를 가진다는 것은 과거에 부여한 '정보'를 저장해서 계속 활용할 수 있다는 것을 의미한다.

### **4.5.2 자세히 살펴보자~!**
- 상태 저장은 '상태'가 전이 된다.
- 다른 예로 상태 저장 프로토콜인 TCP에 경우 시퀀스 번호를 통해 다음 '상태'가 전이 된다.
- 복잡한 처리가 가능하지만, 시스템이 복잡해진다.
- 반대로 상태 비저장에 경우 성능 상태를 고려하지 않기 때문에 간단하며, 성능이나 안전성 측면에서 우수하다.

### **4.5.3 어디에 사용되나**
**컴퓨터 내부 구조**
- CPU는 복수의 프로세스를 조금씩 조금씩 처리하는 방법을 사용함
- 그때 처리하는 프로세스들을 번갈아 가면서 처리하는데, 이때 각 프로세스들에 처리 상태들을 기억해야함
- 또한 인터럽트 단계에서도 인터럽트 enable 플래그라던지 PC 레지스터에 다양한 상태와 데이터를 저장함

**네트워크 통신 구조**
- http 프로토콜에 대표적
- 일반적으로 동일한 데이터 요청시 매번 동일한 데이터를 반환해줌
- 만약 상태 저장 구조라면 이전에 처리해던 데이터를 다시 돌려주겠지만 그게 아니기 때문에 동일한 데이터를 계속해서 반환
- 다만 상태가 있어야만 하는 연산에 대해서는 세션이나, JWT 등을 사용해서 통신하기도 함

### **4.5.4 정리**
- 상태 저장시 처리 내용에 대해서 최소화 및 최적화 작업을 처리할 수있다. 다만 복잡해진다는 단점이 있다. 
- 상태 비저장은 요청과 그에 대한 응답이 일정해서 단순하다.


## **4.6 가변 길이/고정 길이**
### **4.6.1 가변 길이/고정 길이란?**
- 대표적으로 데이터를 저장할때 데이터를 저장하는 단위 크기가 정해져 있다면 고정, 아니라면 가변 길이라고 한다.
- 보통 컴퓨터 내부 메모리등이 고정 길이 상자의 모임이라고 생각하면 쉽다.
- 고정길이에 경우 저장 단위 크기가 정해져 있어서 적은 양을 저장할때 남는 공간이 발생한다.
- 다만 엑세스가 쉽기 때문에 데이터를 관리 할때는 편하다.
- 반대로 가변 길이에 경우 데이터이 파편화라던지 최적화 부분에서는 조금 부족한 부분이 있다.
- 가변 길리의 경우 유용하게 활용 할 수 잇지만 성능 면에서 불안정하다.
- 고정 길이는 필요없는 공간이 생길 수 있지만 성능 면에서는 안정적이다.

### **4.6.2 어디에 사용되나?**
**운영체제 파일 시스템**
- 각 파일 시스템 종류에 따라서 가지고 있는 데이터 저장 단위가 다르다.
- FAT32, NTFS 등등
- 가변 길이 접근 방식에서는 길이 지시자 필드 및 구분 문자를 삽입해서 데이터의 길이를 표현하거나 분리하는데 사용하기도 한다.

**네트워크 데이터 교환**
- 대부분에 네트워크 프로토콜들이 고정 길이에 데이터를 주고 받고 있다.
- 책에 나와있는 예제에도 한번에 보낼 수 있는 데이터의 양을 고려하여, 최초에 데이터는 헤더 값을 제외한 1460, 540 바이트로 분할하고 있다. 

**[허프만 압축 알고리즘](https://ko.wikipedia.org/wiki/%ED%97%88%ED%94%84%EB%A8%BC_%EB%B6%80%ED%98%B8%ED%99%94)**
- 대표적으로 압축 알고리즘 
- 길이가 고정적인 아스키 코드 등 문자 인코딩을 가변 길이의 접두 부호로 변경하여 압축하는 방식


## **4.7 데이터 구조(배열과 연결 리스트)**
### **4.7.1 데이터 구조(배열과 연결 리스트)란?**
- 두 구조 모두 데이터에를 순차적으로 확인할 수 있는 구조이다. 다만 성능이나 쓰임에서 다른면이 많다.
- 다양한 데이터 구조의 기본 구조
  ![array-and-list](img/array-linked-list.png)

**array**
- 배열은 같은 상자를 빈틈없이 순서대로 나열한 데이터 구조다.
- 특징은 상자를 빈틈없이 나열했기 때문에 상자의 번호(index)만 안다면 한번에 접근이 가능하다.
- 중간에 상자가 들어오거나 삭제될 경우 뒤에 있는 모든 상자들을 재정렬해야 하는 작업이 필요하다.
- 추가삭제에 느린 데이터구조이다.

**list**
- 다음 상자의 위치를 기억하고 있는 구조다.
- 일반적으로 상자를 찾기 위해서는 모든 연결 상자들을 지나쳐야 한다.
- 다만 추가/삭제시에 단순히 다음 상자의 위치 내용만 변경해 주면 빠르게 추가/삭제가 가능하다.

**정리**
- 배열은 데이터를 빈틈없이 순서대로 나열한 데이터 구조
- 연결 리스트는 데이터를 선으로 연결한 데이터 구조
- 탐색이 빠른 것은 배열이고, 느린 것은 연결 리스트
- 데이터 추가, 삭제가 빠른 것은 연결 리스트이고, 느린 것은 배열


### **4.7.2 어디에 사용되나?**
- 대표적으로 해시테이블에 사용된다.
  ![hash](img/hash.gif)

- 배열을 통해 해시 인덱스들을 담고 있고, 그 뒤로 리스트를 통해 데이터들이 달려있는 구조
- 실제 사용으로는, DBMS 내부에서 한번 파싱한 쿼리에 대한 데이터를 해시 테이블에 저장해서 사용한다.


### **정리**
- 배열 : N번째 요소 탐색이 빠르다, 데이터 추가/삭제가 느리다.
- 연결 리스트 : 데이터 추가/삭제가 빠르다, N번째 요소 탐색이 느리다.

## **4.8 탐색 알고리즘(해시/트리 등)**

### **4.8.1 탐색 알고리즘(해시/트리 등)이란?**

- 데이터베이스에서 인덱스를 사용하면 왜 검색이 빨라지는 걸까?
- 인덱스를 사용한다고 해서 항상 빨라지는 것이 아닌 이유는 왜일까?
- 기존 DBMS와 인메모리 DB에 적합한 인덱스가 다른 이유는 무엇일까?
- 위 질문들에 공통점은, 데이터를 정리하는 방법인 '데이터 구조'와 데이터를 찾는 방법인 '탐색 알고리즘' 에 대한 문제이다.
- 탐색 알고리즘과 데이터 구조의 본질을 정리하면
  - 필요한 때에 필요한 데이터를 빨게 찾기 위해서 데이터를 정리해 둘 필요가 있다.
  - 데이터를 찾을 때의 데이터 구조와 데이터 저장 방식 특성에 따라 적합한 데이터 정리 방법이 달라진다.
  - 데이터 정리 방법을 '데이터 구조', 처리 순서를 '알고리즘'이라고 한다.
  - 처리 순서에 맞추어 데이터 구조를 정리할 필요가 있기 때문에 '알고리즘과 데이터 구조'는 함께 다루어 진다.

### **4.8.2 어디에 사용되나?**
**DBMS**
- 보통 인덱스를 사용해서 설계를 하면 스캔 속도가 빨라지는 경우가 있다

- **인덱스가 없는 경우**
  - 인덱스가 없다면 디스크에서 테이블 데이터를 모두 순차적으로 읽어서 조사해야 한다. 이것을 풀 스캔(Full Scan) 이라고 한다.
  - 순서가 없는 사전에서 데이터를 찾는것과 비슷하다.
  - 이렇게 되면 모든 테이블에 데이터들을 메모리에 올려서 검색하는 경우가 발생해서 많은 부하와 속도 저하를 가져온다.

- **인덱스가 있는 경우**
  - 일반적으로 인덱스에 사용되는 자료구조는 B트리를 사용한다.
  - 인덱스가 있다면 최소한의 필요 블록만 읽을 수 있다.
  - 다만 검색이 빨라지는 대신에 데이터 추가, 갱신, 삭제 시에 인덱스 갱신에 대한 오버헤드가 발생한다.

- **인덱스의 구조 -B 트리 인덱스**
- B 트리 또한 결국 트리 구조에 검색이다.
- 이진트리와 다른점이 있다면 우선 전체적인 트리의 root 노드부터 leaf 노드까지 높이가 한쪽으로 치우치지 않는다는 것이다.
- 또 다른 특징은 자식 노드의 수가 이진트리와 다르게 여러개 존재한다.
- 이 부분은 노드 접근시간이 노드에서의 연산시간에 비해 훨씬 길 경우 유리한 부분이다. 특히 데이터베이스와 같이 디스크 I/O 작업이 있다면 더 유리하게 작용한다.

**해시 테이블**
- 특정 데이터에 대한 등호 검색에 큰 이점이 있다.
- 그 이유는 key 값을 hash function 이라는 특이한 function 을 사용해서 데이터가 담긴 버킷에 바로 접근이 가능하다는 장점이 있다.
- 해시 테이블에서 장점은 최적의 경우 삽입, 삭제, 검색에서 O(1) 시간 복잡도를 기대할 수 있다는 점이다.
- 최악의 경우에는 O(n)이 나올수도 있지만 해당 부분은 해시 함수의 최적화, 충돌 최적화 등을 통해 극복할 수 있다.
- 단점으로는 범위 검색, 순서가 있는 데이터에는 어울리지 않는다.
- 또한 공간 효율성이 떨어질 수 있다.
- 마지막으로 hash function에 따라서 성능 차이가 많이 난다.