# 02. 코틀린 기초
> **2장에서 다루는 내용**
> * 함수, 변수, 클래스, enum, 프로퍼티를 선언한는 방법  
> * 제어 구조  
> * 스마트 캐스트  
> * 예외 던지기와 예외 잡기

## 2.1. 기본 요소 : 함수와 변수
### 2.1.1 Hello, World! 
    ```kotlin
    fun main(args: Array<String>) {
        println("Hello, World!")
    }
    ```
- 함수를 선언할 때 fun 키워드를 사용한다.
- 파라미터 이름 뒤에 그 파라미터의 타입을 쓴다.
- 함수를 최상위 수준에 정의할 수 있다. 꼭 클래스 안에 함수를 넣어야 할 필요가 없다.
- 배열도 일반적인 클래스와 마찬가지다.
- System.out.println 대신에 println 이라고 쓴다.코틀린 표준 라이브러리는 여러 가지 표준 자바 라이브러리 함수를 간결하게 사용할 수 있게 감싼 레퍼를 제고앟ㄴ다.
- 최신 프로그래밍 언어 경향과 마찬가지로 줄 끝에 세미콜론을 붙이지 않아도 좋다.

### 2.1.2 함수
- 결과를 반환하는 함수의 경우 반환 값의 타입을 어디에 지정해야 할까?
    ```kotlin
    fun max(a: Int, b: Int) : Int {
        return if(a > b) a else b
    }

    println(max(1,2))
    ```
- 함수 선언은 fun 키워드로 시작
- fun 다음에는 함수의 이름이 온다.
- 함수 이름 뒤에는 괄호 안에 파라미터 목록이 온다.
- 함수의 반환 타입은 파라미터 목록의 닫는 괄호 다음에 오는데, 괄호와 반환 타입 사이를 콜론(:)으로 구분해야 한다.


#### 식이 본문인 함수
- 만약 본문이 if 식 하나로만 이루어져 있따면 중괄호를 없애고 return을 제거하면서 등호(=)를 앞에 붙이면 더 간결하게 함수를 표현할 수 있다.
    ```kotlin
    fun max(a: Int, b: Int): Int = if(a>b) a else b
    ```
- 본문이 중괄호로 둘러쌓인 함수를 블록이 본문인 함수
- 등호와 식으로 이뤄진 함수를 식이 본문인 함수
- 반환 타입을 생략하면 max 함수를 더 간략하게 만들 수 있다.
    ```kotlin
    fun max(a: Int, b: Int) = if(a>b) a else b
    ```
- 식이 본문인 함수의 경우 굳이 사용자가 반환 타입을 적지 않아도 컴파일러가 함수 본문 식을 분석해서 식의 결과 타입을 함수 반환 타입으로 정해준다.
- 식이 본문인 함수 타입만 생략 가능하다.

### 2.1.3 변수

- 자바에서 변수를 선언할 때 타입이 맨 앞에 온다.
- 코틀린에서는 타입 지정을 생략하는 경우가 흔하다.
- 타입으로 변수 선언을 시작하면 타입을 생략할 경우 식과 변수 선언을 구별할 수없다. 그런 이유로 코틀린에서는 키워드로 변수 선언을 시작하는 대신 변수 이름 뒤에 타입을 명시하거나 생략하게 허용한다.
    ```kt
    val question = "삶, 우주, 그리고 모든 것에 대한 궁극적인 질문"

    val answer = 42
    // 타입을 표시한다면
    val answer: Int = 42
    ```
- 타입을 지정하지 않으면 컴파일러가 초기화 식을 분석해서 초기화 식의 타입을 변수 타입으로 지정한다.
- val answer = 42 여기서 초기화 식은 42로 Int 타입이다.
- 초기화 식을 사용하지 않고 변수를 선언하려면 변수 타입을 반드시 명시해야 한다. 
    ```kt
    val answer: Int
    answer = 42
    ```
- 초기화 식이 없다면 변수에 저장될 값에 대해 아무 정보가 없기 때문에 컴파일러가 타입을 추론할 수 없다.

#### 변경 가능한 변수와 변경 불가능한 변수
- 변수 선언 시 사용하는 키워드는 다음과 같은 2가지가 있다.
  - val
    - 변경 불가능한 참조를 저장하는변수
    - val로 선언된 변수는 일다 초기화하고 나면 재대입이 불가능하다. 
    - 자바로 말하자면 final 변수에 해당한다. 
  - var
    - 변경 가능한 참조다.
    - 이런 변수의 값은 바뀔 수 있다.
- 기본적으로 모든 변수를 val 키워드를 사용해 불면 변수로 선언하고 나중에 꼭 피룡할 때에만 var로 변경하라
- val 변수는 블록을 실행할 때 정확히 한 번만 초기화돼야 한다.
- 하지만 어떤 블록이 실행될 때 오직 한 초기화 문장만 실행됨을 컴파일러가 확인할 수 있따면 조건에 따라 val 값을 다른 여러가지 값으로 초기화할 수도 있다.
    ```kt
    val message: String
    if(canPerformOperation()) {
        message = "Success"
    } else {
        message = "Failed"
    }
    ```
- val 참조 자체는 불변일지라도 그 참조가 가리키는 객체의 내부 값은 변경될 수 있다.
- var 키워드를 사용하면 변수의 값을 변경할 수 있지만 변수의 타입은 고정돼 바뀌지 않는다.

### 2.1.3 더 쉽게 문자열 형식 지정: 문자열 템플릿
- 아래는 문자열 템플릿 예제 코드이다.

    ```kt
    fun main(args: Array<String>) {
        val name = if (args.size > 0) args[0] else "Kotlin"
        println("Hello, $name")
    }
    ```

- name 이라는 변수를 선언하고 그 다음 줄에 있는 문자열 리러털 안에서 그 변수를 사용했다.
- 문자열 리터럴의 피룡한 곳에 변수를 넣되 변수 앞에 $를 추가해야 한다.
- 자바의 문자열 접합 연사과 동일한 기능
- $ 문자를 문자열에 넣고 싶으면 println("\$x")와 같이 \ 를 사용해 $를 이스케이프 시켜야한다.
- 간단한 변수 이름 말고도 복잡한 식도 중괄호({})로 둘러싸서 문자열 템플릿 안에 넣을 수 있다.
    ```kt
    fun main(args: Array<String>) {
        val name = if (args.size > 0) args[0] else "Kotlin"
        println("Hello, $name")

        if (args.size > 0) {
            println("Hello, ${args[0]}")
        }
    }
    ```


## 2.2 클래스와 프로퍼티