# 02. 코틀린 기초
> **2장에서 다루는 내용**
> * 함수, 변수, 클래스, enum, 프로퍼티를 선언한는 방법  
> * 제어 구조  
> * 스마트 캐스트  
> * 예외 던지기와 예외 잡기

## 2.1. 기본 요소 : 함수와 변수
### 2.1.1 Hello, World! 
    ```kotlin
    fun main(args: Array<String>) {
        println("Hello, World!")
    }
    ```
- 함수를 선언할 때 fun 키워드를 사용한다.
- 파라미터 이름 뒤에 그 파라미터의 타입을 쓴다.
- 함수를 최상위 수준에 정의할 수 있다. 꼭 클래스 안에 함수를 넣어야 할 필요가 없다.
- 배열도 일반적인 클래스와 마찬가지다.
- System.out.println 대신에 println 이라고 쓴다.코틀린 표준 라이브러리는 여러 가지 표준 자바 라이브러리 함수를 간결하게 사용할 수 있게 감싼 레퍼를 제고앟ㄴ다.
- 최신 프로그래밍 언어 경향과 마찬가지로 줄 끝에 세미콜론을 붙이지 않아도 좋다.

### 2.1.2 함수
- 결과를 반환하는 함수의 경우 반환 값의 타입을 어디에 지정해야 할까?
    ```kotlin
    fun max(a: Int, b: Int) : Int {
        return if(a > b) a else b
    }

    println(max(1,2))
    ```
- 함수 선언은 fun 키워드로 시작
- fun 다음에는 함수의 이름이 온다.
- 함수 이름 뒤에는 괄호 안에 파라미터 목록이 온다.
- 함수의 반환 타입은 파라미터 목록의 닫는 괄호 다음에 오는데, 괄호와 반환 타입 사이를 콜론(:)으로 구분해야 한다.


#### 식이 본문인 함수
- 만약 본문이 if 식 하나로만 이루어져 있따면 중괄호를 없애고 return을 제거하면서 등호(=)를 앞에 붙이면 더 간결하게 함수를 표현할 수 있다.
    ```kotlin
    fun max(a: Int, b: Int): Int = if(a>b) a else b
    ```
- 본문이 중괄호로 둘러쌓인 함수를 블록이 본문인 함수
- 등호와 식으로 이뤄진 함수를 식이 본문인 함수
- 반환 타입을 생략하면 max 함수를 더 간략하게 만들 수 있다.
    ```kotlin
    fun max(a: Int, b: Int) = if(a>b) a else b
    ```
- 식이 본문인 함수의 경우 굳이 사용자가 반환 타입을 적지 않아도 컴파일러가 함수 본문 식을 분석해서 식의 결과 타입을 함수 반환 타입으로 정해준다.
- 식이 본문인 함수 타입만 생략 가능하다.

### 2.1.3 변수

- 자바에서 변수를 선언할 때 타입이 맨 앞에 온다.
- 코틀린에서는 타입 지정을 생략하는 경우가 흔하다.
- 타입으로 변수 선언을 시작하면 타입을 생략할 경우 식과 변수 선언을 구별할 수없다. 그런 이유로 코틀린에서는 키워드로 변수 선언을 시작하는 대신 변수 이름 뒤에 타입을 명시하거나 생략하게 허용한다.
    ```kt
    val question = "삶, 우주, 그리고 모든 것에 대한 궁극적인 질문"

    val answer = 42
    // 타입을 표시한다면
    val answer: Int = 42
    ```
- 타입을 지정하지 않으면 컴파일러가 초기화 식을 분석해서 초기화 식의 타입을 변수 타입으로 지정한다.
- val answer = 42 여기서 초기화 식은 42로 Int 타입이다.
- 초기화 식을 사용하지 않고 변수를 선언하려면 변수 타입을 반드시 명시해야 한다. 
    ```kt
    val answer: Int
    answer = 42
    ```
- 초기화 식이 없다면 변수에 저장될 값에 대해 아무 정보가 없기 때문에 컴파일러가 타입을 추론할 수 없다.

#### 변경 가능한 변수와 변경 불가능한 변수
- 변수 선언 시 사용하는 키워드는 다음과 같은 2가지가 있다.
  - val
    - 변경 불가능한 참조를 저장하는변수
    - val로 선언된 변수는 일다 초기화하고 나면 재대입이 불가능하다. 
    - 자바로 말하자면 final 변수에 해당한다. 
  - var
    - 변경 가능한 참조다.
    - 이런 변수의 값은 바뀔 수 있다.
- 기본적으로 모든 변수를 val 키워드를 사용해 불면 변수로 선언하고 나중에 꼭 피룡할 때에만 var로 변경하라
- val 변수는 블록을 실행할 때 정확히 한 번만 초기화돼야 한다.
- 하지만 어떤 블록이 실행될 때 오직 한 초기화 문장만 실행됨을 컴파일러가 확인할 수 있따면 조건에 따라 val 값을 다른 여러가지 값으로 초기화할 수도 있다.
    ```kt
    val message: String
    if(canPerformOperation()) {
        message = "Success"
    } else {
        message = "Failed"
    }
    ```
- val 참조 자체는 불변일지라도 그 참조가 가리키는 객체의 내부 값은 변경될 수 있다.
- var 키워드를 사용하면 변수의 값을 변경할 수 있지만 변수의 타입은 고정돼 바뀌지 않는다.

### 2.1.3 더 쉽게 문자열 형식 지정: 문자열 템플릿
- 아래는 문자열 템플릿 예제 코드이다.

    ```kt
    fun main(args: Array<String>) {
        val name = if (args.size > 0) args[0] else "Kotlin"
        println("Hello, $name")
    }
    ```

- name 이라는 변수를 선언하고 그 다음 줄에 있는 문자열 리러털 안에서 그 변수를 사용했다.
- 문자열 리터럴의 피룡한 곳에 변수를 넣되 변수 앞에 $를 추가해야 한다.
- 자바의 문자열 접합 연사과 동일한 기능
- $ 문자를 문자열에 넣고 싶으면 println("\$x")와 같이 \ 를 사용해 $를 이스케이프 시켜야한다.
- 간단한 변수 이름 말고도 복잡한 식도 중괄호({})로 둘러싸서 문자열 템플릿 안에 넣을 수 있다.
    ```kt
    fun main(args: Array<String>) {
        val name = if (args.size > 0) args[0] else "Kotlin"
        println("Hello, $name")

        if (args.size > 0) {
            println("Hello, ${args[0]}")
        }
    }
    ```


## 2.2 클래스와 프로퍼티
- 아래는 간단한 자바빈 클래스이다.
    ```java
    public class Person {
        private final String name;

        public Person(String name) {
            this.name = name;
        }

        public String getName(){
            return name;
        }
    }
    ```
- 필드가 둘 이상 늘어나면 생성자인 Person(String name)의 본문에서 파라미터를 이름이 같은 필드에 대입하는 대입문의 수도 늘어난다.
- 코틀린에서는 그런 필드 대입 로직을 훨씬 더 적은 코드로 작성할 수 있다.

    ```kt
    // 코틀린으로 변환한 Person 클래스
    class Person(val name: String)
    ```
- 이런 유형의 클래스를 값 객체라 부른다.
- 또한 가시성 변경자 public 키워드가 사라졌다. 코틀린의 기본 가시성은 public이므로 이런 경우 변경자를 생략해도 된다.

### 2.2.1 프로퍼티

- 자바에서는 맴버 필드의 가시성은 보통 비공개(private)다. 그리고 데이터에 접근하는 통로로 쓸 수 있는 접근자 메소드를 제공한다.
- 자바에서는 필드와 접근자를 한데 묶어 프로퍼티라고 부른다.
- 코틀린은 프로퍼티를 언어 기본 기능으로 제공하며, 코틀린 프로퍼티는 자바의 필드와 접근자 메소드를 완전히 대신한다.
- val로 선언한 프로퍼티는 읽기 전용이며, var로 선언한 프로퍼티는 변경이 가능하다.

    ```kt
    class Person(
        val name: String, //  읽기 전용 프로퍼티
        var isMarried: Boolean // 쓸 수 있는 프로퍼티
    )
    ```

- is로 시작하는 프로펕의 게터에는 get이 붙지 않고 원래 이름을 그대로 사용하며, 세터에는 is를 set으로 바꾼 이름을 사용한다.
- 프로퍼티 이름을 직접 사용해도 코틀린 자동으로 접근자 메소드를 호출해준다.
    ```kt
    fun main(args: Array<String>) {
        val person = Person("Bob", true)
        println(person.name) // 프로퍼티 이름을 직접 사용해도 코틀린 자동으로 게터를 호출해준다.
        println(person.isMarried)

        person.isMarried = false // 세터도 마찬가지 방식으로 동작
        println(person.isMarried)
    }
    ```
- 대부분의 프로퍼티에는 값을 저장하기 위한 필드가 있다. 이를 프로퍼티를 뒷받침하는 필드라고 부른다.
- 하지만 원한다면 프로퍼티 값을 그때그때 계산할 수도 있다. 커스텀 게터를 작성하면 그런 프로퍼티를 만들 수 있다.

### 2.2.2 커스텀 접근자
- 사각형 클래스인 Rectangle를 정의하면서 자신이 정사각형인지 알려주는 기능 예제이다.

    ```kt
    class Rectangle(val height: Int, val width: Int) {
        val isSquare: Boolean
            get() {
                return height == width
            }
    }
    ```

- 위 예제에서 isSquare 프로퍼티는 자체 값을 저장하는 필드가 필요없다.


### 2.2.3 코틀린 소스코드 구조: 디렉터리와 패키지
- 코틀린에도 자바와 비슷한 개념의 패키지가 있다.
- 코틀린 파일의 맨 앞에 package 문을 넣을 수 있다.
- 같은 패키지에 속해 있다면 다른 파일에서 정의한 선언일지라도 직접 사용할 수 있다.
- 반면 다른 패키지에 정의한 선언을 사용하려면 임포트를 통해 선언을 불러와야 한다.
- 아래는 패키지 선언과 임포트문을 보여주는 예제이다.

    ```kt
    package com.jaehyun.kotlin.study.study.ch02 // 패키지 선언

    import java.util.Random // 표준 자바 라이브러리 클래스를 임포트

    class Rectangle(val height: Int, val width: Int) {
        val isSquare: Boolean
            get() {
                return height == width
            }
    }

    fun createRandomRectangle(): Rectangle {
        val random = Random();
        return Rectangle(random.nextInt(), random.nextInt());
    }
    ```

- 코틀린에서는 클래스 임포트와 함수 임포트에 차이가 없으며, 모든 선언을 import 키워드로 가져올 수있다.

    ```kt
    package com.jaehyun.kotlin.study.study.ch02example

    import com.jaehyun.kotlin.study.study.ch02.createRandomRectangle

    fun main(args: Array<String>){
        println(createRandomRectangle().isSquare)
    }

    ```
- 패키지 이름 뒤에 .*를 추가하면 패키지 안 모든 선언을 임포트할 수 있다.
- 코틀린에서느 여러 클래스를 한 파일에 넣고 파일 이름도 마음대로 정할 수 있다.